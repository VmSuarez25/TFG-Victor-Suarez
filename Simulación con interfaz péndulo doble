import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from matplotlib.widgets import TextBox
import os

# Clase para encapsular el péndulo doble
class PénduloDoble:
    def __init__(self, masa1, masa2, longitud1, longitud2, centro_masa_1, centro_masa_2, inercia1, inercia2, gravedad, friccion_aire=0.1, friccion_rod1=0, friccion_rod2=0):
        self.masa1, self.masa2 = masa1, masa2 # Masas de los eslabones
        self.longitud1, self.longitud2 = longitud1, longitud2 # Longitudes de los eslabones
        self.centro_masa_1, self.centro_masa_2 = centro_masa_1, centro_masa_2 # Distancia entre las articulaciones y el centro de masa del eslabón
        self.inercia1, self.inercia2 = inercia1, inercia2 # Momentos de inercia
        self.gravedad, self.friccion_rod1, self.friccion_rod2 = gravedad, friccion_rod1, friccion_rod2 # Constante de la aceleración gravitatoria, fricción rodamiento 1 y fricción rodamiento 2
        self.friccion_aire = friccion_aire  # Coeficiente de resistencia del aire
        self.M11_const = masa1 * centro_masa_1**2 + masa2 * longitud1**2 + inercia1 # Término 11 de la matriz de inercia
        self.M22_const = masa2 * centro_masa_2**2 + inercia2 # Término 22 de la matriz de inercia
        self.angulo = None
        self.vel_ang = None

 # Condiciones iniciales para ángulos y velocidades angulares (pasamos de grados a radianes) 
    def establecer_condiciones_iniciales(self, angulo1_i, angulo2_i, vel_ang1_i=0.0, vel_ang2_i=0.0):
        self.angulo = np.array([np.radians(angulo1_i), np.radians(angulo2_i)])
        self.vel_ang = np.array([vel_ang1_i, vel_ang2_i])

# Modelo dinámico: MÖ + CO' + DO + GO = tau 
    def calcular_matrices_sistema(self):
        angulo, vel_ang = self.angulo, self.vel_ang
        M11 = self.M11_const
        M12 = self.masa2 * self.longitud1 * self.centro_masa_2 * np.cos(angulo[0] - angulo[1])
        MM = np.array([[M11, M12], [M12, self.M22_const]])

        # Matriz de Coriolis
        k = self.masa2 * self.longitud1 * self.centro_masa_2 * np.sin(angulo[0] - angulo[1])
        CC = np.array([[0, k * vel_ang[1]], [-k * vel_ang[0], 0]])
        
        # Matriz fuerzas gravitacionales
        GG = np.array([(self.masa1 * self.centro_masa_1 + self.masa2 * self.longitud1) * self.gravedad * np.sin(angulo[0]), 
                       self.masa2 * self.centro_masa_2 * self.gravedad * np.sin(angulo[1])])
        
        # Matriz de rozamiento
        DD = np.diag([self.friccion_rod1 + self.friccion_aire, self.friccion_rod2 + self.friccion_aire])
        
        return MM, CC, GG, DD

    def integrar_dinamica(self, dt):
        torque = np.zeros(2) # Asumiendo que no hay torques externos
        MM, CC, GG, DD = self.calcular_matrices_sistema()
        
        # Aquí resolvemos la ecuación para obtener teta punto punto 
        def derivadas(angulo, vel_ang):
            return np.linalg.inv(MM) @ (torque - CC @ vel_ang - DD @ vel_ang - GG)
        # MÖ=t-CO(punto)-DO(punto)-G
        # En Python, np.linalg.inv calcula la inversa de la matriz
        # @ realiza multiplicaciones de matrices
        
        # Este código utiliza el método RK4 para resolver las ecuaciones diferenciales del péndulo doble de
        # manera más precisa que un método simple como Euler. En lugar de avanzar directamente con una
        # sola estimación, RK4 toma cuatro "muestras" a lo largo del intervalo de tiempo (dt) y las combina
        # para obtener una aproximación más exacta del siguiente estado del sistema. Esto es especialmente
        # útil para sistemas no lineales como el péndulo doble, que puede exhibir comportamiento caótico.
        k1v = self.vel_ang
        k1a = derivadas(self.angulo, self.vel_ang)
        k2v = self.vel_ang + 0.5 * dt * k1a
        k2a = derivadas(self.angulo + 0.5 * dt * k1v, self.vel_ang + 0.5 * dt * k1a)
        k3v = self.vel_ang + 0.5 * dt * k2a
        k3a = derivadas(self.angulo + 0.5 * dt * k2v, self.vel_ang + 0.5 * dt * k2a)
        k4v = self.vel_ang + dt * k3a
        k4a = derivadas(self.angulo + dt * k3v, self.vel_ang + dt * k3a)
        
        self.angulo += (dt / 6) * (k1v + 2*k2v + 2*k3v + k4v)
        self.vel_ang += (dt / 6) * (k1a + 2*k2a + 2*k3a + k4a)
        
        fuerza_rozamiento = np.dot(DD, self.vel_ang) # F=-b·v
        
        return self.angulo, self.vel_ang

    def cinematica_directa(self):
        x1 = self.longitud1 * np.sin(self.angulo[0])
        y1 = -self.longitud1 * np.cos(self.angulo[0])
        x2 = x1 + self.longitud2 * np.sin(self.angulo[1])
        y2 = y1 - self.longitud2 * np.cos(self.angulo[1])
        return (x1, y1), (x2, y2)

# Configuración inicial de parámetros predeterminados
parametros = {
    'masa1': 1.0, 'masa2': 3.0, 'longitud1': 1.5, 'longitud2': 1.0, 'masa_barra': 0.1, 'radio_barra': 0.05,
    'angulo1_i': 90.0, 'angulo2_i': 0.0, 'friccion_aire': 0.1
}

# DEFINIMOS LOS PARÁMETROS INICIALES
tiempo_max = 30 # Es el tiempo que durará la simulación (solo afecta si guardamos el video)

# El intervalo de tiempo que se usa para avanzar en la simulación. Reducimos dt para mejorar la fluidez.
dt = 1/60 # 60 fps

# Inicializamos el péndulo con valores predeterminados
masa1 = parametros['masa1'] + parametros['masa_barra']
masa2 = parametros['masa2'] + parametros['masa_barra']
longitud1 = parametros['longitud1'] + parametros['radio_barra']
longitud2 = parametros['longitud2'] + parametros['radio_barra']
inercia1 = (1/3) * masa1 * longitud1**2 # kgm^2, momento de inercia de una barra delgada respecto a un eje perpendicular que pasa por su extremo
inercia2 = (1/3) * masa2 * longitud2**2
gravedad = 9.8007 # m/s^2, aceleración de la gravedad (Madrid, España)
friccion_rod1 = 0
friccion_rod2 = 0
friccion_aire = parametros['friccion_aire']
centro_masa_1 = ((longitud1/2)*parametros['masa1'] + longitud1*parametros['masa_barra'])/masa1 # Calculado en apuntes
centro_masa_2 = ((longitud2/2)*parametros['masa2'] + longitud2*parametros['masa_barra'])/masa2 # Calculado en apuntes

pendulo = PénduloDoble(masa1, masa2, longitud1, longitud2, centro_masa_1, centro_masa_2, inercia1, inercia2, gravedad, friccion_aire, friccion_rod1, friccion_rod2)
pendulo.establecer_condiciones_iniciales(parametros['angulo1_i'], parametros['angulo2_i'])

# Diseño del péndulo
color_eslabon = 'black'
color_masa1 = 'green'
color_masa2 = 'red'
color_trayectoria = 'blue'

trayectoria = []

# Ajustes del recuadro
fig, ax = plt.subplots(figsize=(14, 8))
plt.subplots_adjust(bottom=0.15, top=0.9)
longitud_max = longitud1 + longitud2 + 0.5 # Ajustamos para abarcar la longitud total del péndulo más un margen
ax.set_xlim(-longitud_max, longitud_max)
ax.set_ylim(-longitud_max, longitud_max + 1)
ax.set_aspect('equal', adjustable='box')
ax.set_xlabel('X (m)')
ax.set_ylabel('Y (m)')
ax.set_title('Simulación de Péndulo Doble')

barra, = ax.plot([], [], '-', lw=2, color=color_eslabon) # Línea que representa las barras
masa1, = ax.plot([], [], 'o', markersize=10, color=color_masa1) # Representa la masa en el primer eslabón
masa2, = ax.plot([], [], 'o', markersize=10, color=color_masa2) # Representa la masa en el segundo eslabón
traza, = ax.plot([], [], '-', lw=1, color=color_trayectoria) # Trazado que describe el rodamiento 2
texto_tiempo = ax.text(0.1, 0.95, '', transform=ax.transAxes)  # Texto del tiempo

# Campos de texto para entrada dentro de la animación
def actualizar_parametro(param, val):
    try:
        valor = float(val)
        if valor > 0 or param in ['angulo1_i', 'angulo2_i']:
            parametros[param] = valor
            reiniciar_pendulo()
    except ValueError:
        pass

def reiniciar_pendulo():
    global pendulo, longitud_max
    masa1 = parametros['masa1'] + parametros['masa_barra']
    masa2 = parametros['masa2'] + parametros['masa_barra']
    longitud1 = parametros['longitud1'] + parametros['radio_barra']
    longitud2 = parametros['longitud2'] + parametros['radio_barra']
    inercia1 = (1/3) * masa1 * longitud1**2
    inercia2 = (1/3) * masa2 * longitud2**2
    centro_masa_1 = ((longitud1/2)*parametros['masa1'] + longitud1*parametros['masa_barra'])/masa1
    centro_masa_2 = ((longitud2/2)*parametros['masa2'] + longitud2*parametros['masa_barra'])/masa2
    pendulo = PénduloDoble(masa1, masa2, longitud1, longitud2, centro_masa_1, centro_masa_2, inercia1, inercia2, gravedad, parametros['friccion_aire'], friccion_rod1, friccion_rod2)
    pendulo.establecer_condiciones_iniciales(parametros['angulo1_i'], parametros['angulo2_i'])
    longitud_max = longitud1 + longitud2 + 0.5
    ax.set_xlim(-longitud_max, longitud_max)
    ax.set_ylim(-longitud_max, longitud_max + 1)
    trayectoria.clear()

# Ajustes para los TextBox 
ancho_caja_texto = 0.08
alto_caja_texto = 0.03
margen_izquierdo = 0.15  # Usamos margen_izquierdo en lugar de center_offset
separacion = 0.17  # Ajustamos la separación para que coincida

# Primera fila (5 cajas) - Mantenemos en y=0.01, usando margen_izquierdo en lugar de center_offset
ax_masa1 = plt.axes([margen_izquierdo, 0.01, ancho_caja_texto, alto_caja_texto])
ax_masa2 = plt.axes([margen_izquierdo + separacion, 0.01, ancho_caja_texto, alto_caja_texto])
ax_longitud1 = plt.axes([margen_izquierdo + 2*separacion, 0.01, ancho_caja_texto, alto_caja_texto])
ax_longitud2 = plt.axes([margen_izquierdo + 3*separacion, 0.01, ancho_caja_texto, alto_caja_texto])
ax_masa_barra = plt.axes([margen_izquierdo + 4*separacion, 0.01, ancho_caja_texto, alto_caja_texto])

# Segunda fila (4 cajas) - Mantenemos en y=0.06, usando margen_izquierdo en lugar de center_offset
ax_radio_barra = plt.axes([margen_izquierdo, 0.06, ancho_caja_texto, alto_caja_texto])
ax_friccion_aire = plt.axes([margen_izquierdo + separacion, 0.06, ancho_caja_texto, alto_caja_texto])
ax_angulo1 = plt.axes([margen_izquierdo + 2*separacion, 0.06, ancho_caja_texto, alto_caja_texto])
ax_angulo2 = plt.axes([margen_izquierdo + 3*separacion, 0.06, ancho_caja_texto, alto_caja_texto])

caja_texto_masa1 = TextBox(ax_masa1, 'M1 (kg)', initial=str(parametros['masa1']))
caja_texto_masa2 = TextBox(ax_masa2, 'M2 (kg)', initial=str(parametros['masa2']))
caja_texto_longitud1 = TextBox(ax_longitud1, 'L1 (m)', initial=str(parametros['longitud1']))
caja_texto_longitud2 = TextBox(ax_longitud2, 'L2 (m)', initial=str(parametros['longitud2']))
caja_texto_masa_barra = TextBox(ax_masa_barra, 'MRod (kg)', initial=str(parametros['masa_barra']))
caja_texto_radio_barra = TextBox(ax_radio_barra, 'Radio Rod (m)', initial=str(parametros['radio_barra']))
caja_texto_friccion_aire = TextBox(ax_friccion_aire, 'Res. Aire', initial=str(parametros['friccion_aire']))
caja_texto_angulo1 = TextBox(ax_angulo1, 'Ángulo 1 (deg)', initial=str(parametros['angulo1_i']))
caja_texto_angulo2 = TextBox(ax_angulo2, 'Ángulo 2 (deg)', initial=str(parametros['angulo2_i']))

caja_texto_masa1.on_submit(lambda val: actualizar_parametro('masa1', val))
caja_texto_masa2.on_submit(lambda val: actualizar_parametro('masa2', val))
caja_texto_longitud1.on_submit(lambda val: actualizar_parametro('longitud1', val))
caja_texto_longitud2.on_submit(lambda val: actualizar_parametro('longitud2', val))
caja_texto_masa_barra.on_submit(lambda val: actualizar_parametro('masa_barra', val))
caja_texto_radio_barra.on_submit(lambda val: actualizar_parametro('radio_barra', val))
caja_texto_friccion_aire.on_submit(lambda val: actualizar_parametro('friccion_aire', val))
caja_texto_angulo1.on_submit(lambda val: actualizar_parametro('angulo1_i', val))
caja_texto_angulo2.on_submit(lambda val: actualizar_parametro('angulo2_i', val))

def inicializar():
    barra.set_data([], [])
    masa1.set_data([], [])
    masa2.set_data([], [])
    traza.set_data([], [])
    texto_tiempo.set_text('')
    return barra, masa1, masa2, traza, texto_tiempo

def animar(i):
    pendulo.integrar_dinamica(dt)
    (x1, y1), (x2, y2) = pendulo.cinematica_directa()
    
    # Actualizamos la barra y las masas
    barra.set_data([0, x1, x2], [0, y1, y2]) # Dibujamos la barra completa
    masa1.set_data([x1], [y1]) # Posición de la primera masa
    masa2.set_data([x2], [y2]) # Posición de la segunda masa
    trayectoria.append((x2, y2))
    traza.set_data(*zip(*trayectoria))
    texto_tiempo.set_text(f'Tiempo = {dt * i:.1f}s')
    return barra, masa1, masa2, traza, texto_tiempo

anim = FuncAnimation(fig, animar, init_func=inicializar, frames=int(tiempo_max/dt*2), interval=dt*1000/2, blit=True)

plt.show()
